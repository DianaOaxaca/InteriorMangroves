---
title: "Core microbiome"
---

## Load libraries and prepare data

```{r}
#| label: libraries
#| message: false
#| warning: false
# load libraries
library(phyloseq)
library(microbiome)
library(dplyr)
```

```{r}
#load data
physeq_qiime3 <- readRDS("rds/compare_mangroves/physeq_qiime3.rds")
```

```{r}
#Mangrove system colors
loc_colors <- c("Fossil Lagoon"= "#A7fcc1",
                "San Pedro River" = "#26B170",
                "Términos Lagoon" = "#329D9C",
                "Celestún Lagoon" = "#41e8d3")
```

```{}
```

## Calculate core

```{r}
#| eval: false
#| include: false
# Prevalence threshold
prevalence_threshold <- 0.8

# Storage ASVs core list
core_list <- list()
locations <- levels(sample_data(physeq_qiime3)$Location)

# Calculate core
for (loc in locations) {
  # Filter samples by mangrove system
  physeq_loc <- prune_samples(sample_data(physeq_qiime3)$Mangrove.system == loc, physeq_qiime3)
  n_samples_loc <- nsamples(physeq_loc)

  # Extraer la tabla de OTUs
  otu <- as(otu_table(physeq_loc), "matrix")

  # Calcular prevalencia
  prevalence <- rowSums(otu > 0) / n_samples_loc

  # Identificar ASVs con prevalencia >= umbral
  core_taxa <- names(prevalence)[prevalence >= prevalence_threshold]

  # Guardar en la lista
  core_list[[loc]] <- core_taxa
}

# Mostrar cuántas ASVs core hay por Location
print(lapply(core_list, length))

# Si está vacío, probar con umbral = 1
if (all(sapply(core_list, length) == 0)) {
  cat("Probando con umbral de prevalencia = 1...\n")
  prevalence_threshold <- 1.0
  core_list <- list()
  for (loc in locations) {
    physeq_loc <- prune_samples(sample_data(physeq_qiime3)$Location == loc, physeq_qiime3)
    n_samples_loc <- nsamples(physeq_loc)
    otu <- as(otu_table(physeq_loc), "matrix")
    prevalence <- rowSums(otu > 0) / n_samples_loc
    core_taxa <- names(prevalence)[prevalence >= prevalence_threshold]
    core_list[[loc]] <- core_taxa
  }
  print(lapply(core_list, length))
}


# Cargar librería para UpSet
library(UpSetR)

# Crear una lista de todas las ASVs únicas en el core
all_core_asvs <- unique(unlist(core_list))

# Crear una matriz binaria de presencia/ausencia
core_matrix <- matrix(0, nrow = length(all_core_asvs), ncol = length(locations),
                      dimnames = list(all_core_asvs, locations))

# Rellenar la matriz: 1 si la ASV está en el core de la Location, 0 si no
for (loc in locations) {
  core_matrix[core_list[[loc]], loc] <- 1
}

# Convertir a data frame para UpSetR
core_df <- as.data.frame(core_matrix)

# Cargar librería
library(UpSetR)

# Crear una lista de queries solo para intersecciones con datos
queries_list <- list()

# Fossil Lagoon (270 ASVs únicas)
queries_list <- append(queries_list, list(
  list(query = intersects, params = list("Fossil Lagoon"), color = "#A7FCC1",
       active = TRUE, query.name = "Fossil Lagoon")
))

# San Pedro River (256 ASVs únicas)
queries_list <- append(queries_list, list(
  list(query = intersects, params = list("San Pedro River"), color = "#26B170",
       active = TRUE, query.name = "San Pedro River")
))

# Estero Pargo (1 ASV única)
queries_list <- append(queries_list, list(
  list(query = intersects, params = list("Estero Pargo"), color = "#329D9C",
       active = TRUE, query.name = "Estero Pargo")
))

# Celestún (186 ASVs únicas)
queries_list <- append(queries_list, list(
  list(query = intersects, params = list("Celestún"), color = "#41E8D3",
       active = TRUE, query.name = "Celestún")
))

# Core (6 ASVs)
queries_list <- append(queries_list, list(
  list(query = intersects, params = list("Fossil Lagoon", "San Pedro River",
                                         "Estero Pargo", "Celestún"),
       color = "#8D3CA3", active = TRUE, query.name = "Core")
))

# Interior (196 ASVs)
queries_list <- append(queries_list, list(
  list(query = intersects, params = list("Fossil Lagoon", "San Pedro River"),
       color = "#356E48", active = TRUE, query.name = "Interior")
))

# Crear el gráfico UpSet sin nintersects
upset_plot <- upset(core_df,
                    sets = colnames(core_df),
                    order.by = "freq",
                    mainbar.y.label = "Shared ASVs",
                    sets.x.label = "ASVs per Site",
                    text.scale = 1.5,
                    point.size = 4,
                    line.size = 1.5,
                    query.legend = "top",
                    sets.bar.color =
                      c("#329D9C","#41E8D3","#A7FCC1","#26B170"),
                    queries = queries_list)

# Mostrar el gráfico
print(upset_plot)

pdf("results/meta-analisis/core_upset.pdf", width = 5.8, height = 4)
upset_plot
dev.off()

## combine plots
library(ggplot2)
library(cowplot)

beta_and_core <- plot_grid(nmds_plot_bray_perm, upset_plot,
                         labels = c("B)", "C)"), ncol = 1)
alpha_beta_and_core <- plot_grid(q012y_plot, beta_and_core, ncol = 2,
                           rel_widths = c(0.7, 1.2))

alpha_beta_and_core

ggsave("results/meta-analisis/alpha_beta_core.pdf",
       alpha_beta_and_core, width = 12, height = 11)

### get unique ASVs per Location
# Identificar las ASVs únicas por Location
unique_asvs <- list()
for (loc in colnames(core_df)) {
  unique_asvs[[loc]] <- rownames(core_df)[rowSums(core_df == 1) == 1 & core_df[[loc]] == 1]
  cat(loc, ": Número de ASVs únicas:", length(unique_asvs[[loc]]), "\n")
  print(head(unique_asvs[[loc]], 5))  # Mostrar las primeras 5 ASVs como ejemplo
}
unique_asvs

# Verificar si hay una tabla taxonómica
if (!is.null(tax_table(physeq_qiime3))) {
  tax_table_df <- as.data.frame(tax_table(physeq_qiime3))

  # Función para obtener la taxonomía de una lista de ASVs
  get_taxonomy <- function(asv_list) {
    if (length(asv_list) > 0) {
      taxonomy <- tax_table_df[asv_list, , drop = FALSE]
      return(taxonomy)
    } else {
      return(NULL)
    }
  }

  # Obtener taxonomía para las ASVs únicas de cada Location
  taxonomy_unique <- lapply(unique_asvs, get_taxonomy)

  # Mostrar la taxonomía de las primeras 5 ASVs únicas por Location
  for (loc in names(taxonomy_unique)) {
    cat("\nTaxonomía de las primeras 5 ASVs únicas en", loc, ":\n")
    if (!is.null(taxonomy_unique[[loc]])) {
      print(head(taxonomy_unique[[loc]], 5))
    } else {
      cat("No hay ASVs únicas para", loc, "\n")
    }
  }
} else {
  cat("No se encontró una tabla taxonómica en physeq_qiime3. Por favor, importa la taxonomía.\n")
}

# Mostrar la taxonomía completa de las ASVs únicas por Location
for (loc in names(taxonomy_unique)) {
  cat("\nTaxonomía de todas las ASVs únicas en", loc, ":\n")
  if (!is.null(taxonomy_unique[[loc]])) {
    print(taxonomy_unique[[loc]])
  } else {
    cat("No hay ASVs únicas para", loc, "\n")
  }
}
# Confirmar el número total de ASVs únicas por Location
lapply(taxonomy_unique, function(x) if (!is.null(x)) nrow(x) else 0)

# Crear una lista para almacenar las familias únicas por Location
families_unique <- list()

# Iterar sobre cada Location
for (loc in names(taxonomy_unique)) {
  if (!is.null(taxonomy_unique[[loc]])) {
    # Extraer el nivel taxonómico de Familia
    tax_df <- taxonomy_unique[[loc]]
    if ("Family" %in% colnames(tax_df)) {
      # Obtener las familias presentes
      families <- tax_df$Family
      families <- families[!is.na(families)]  # Excluir NA
      families_unique[[loc]] <- unique(families)  # Familias únicas para esta Location
    } else {
      cat("El nivel taxonómico 'Family' no está disponible en la tabla taxonómica para", loc, "\n")
      families_unique[[loc]] <- character(0)
    }
  } else {
    families_unique[[loc]] <- character(0)
  }
}

# Identificar familias que son exclusivas de cada Location
all_families <- unique(unlist(families_unique))
families_exclusive <- list()
for (loc in names(families_unique)) {
  other_locations <- setdiff(names(families_unique), loc)
  other_families <- unique(unlist(families_unique[other_locations]))
  exclusive_families <- setdiff(families_unique[[loc]], other_families)
  families_exclusive[[loc]] <- exclusive_families
  cat("Familias exclusivas en", loc, ":", length(exclusive_families), "\n")
  if (length(exclusive_families) > 0) {
    print(exclusive_families)
  } else {
    cat("No hay familias exclusivas.\n")
  }
}

# Combinar las taxonomías en un solo data.frame
taxonomy_unique_df <- do.call(rbind, lapply(names(taxonomy_unique), function(loc) {
  if (!is.null(taxonomy_unique[[loc]])) {
    df <- taxonomy_unique[[loc]]
    df$Location <- loc  # Añadir columna Location
    df$ASV <- rownames(df)  # Añadir columna con el nombre de la ASV
    return(df)
  } else {
    return(NULL)
  }
}))

# Mover la columna ASV al inicio y Location después
taxonomy_unique_df <- taxonomy_unique_df[, c("ASV", "Location", setdiff(names(taxonomy_unique_df), c("ASV", "Location")))]

# Mostrar las primeras filas del data.frame para verificar
cat("Primeras filas del data.frame combinado:\n")
print(head(taxonomy_unique_df))

# Verificar el número total de filas
cat("Número total de filas (ASVs únicas):", nrow(taxonomy_unique_df), "\n")

# Guardar el data.frame como CSV
write.csv(taxonomy_unique_df, file = "results/meta-analisis/unique_asvs_taxonomy.csv", row.names = FALSE)

```
